<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Inventory Website</title>
  <style>
    body {
      margin: 0;
      font-family: Arial, sans-serif;
    }
    .search {
        color: #666;
        border-top: 0 none;
        overflow: hidden;
        margin: 0;
        padding: 4px 6px 0 4px;
        position: absolute;
        top: 51px;
        right:50px;
        z-index: 99;
        white-space: normal;
    }
    .search.left {
        border-left: 0 none;
        border-radius: 0px 0px 5px 0px;
        left: 0;
    }
    .search.right {
        border-radius: 0px 0px 0px 5px;
        border-right: 0 none;
        right: 0;
    }
    .search_form {
        margin: 0 20px 4px 0;
        overflow: hidden;
        line-height: 1.9;
        outline: 1px solid blue;
    }
    .search_field {
        border-radius: 3px 0 0 3px;
        background-color: white;
        color: black;
        border: 1px solid #cbcbcb;
        border-right: 0 none;
        outline: 0;
        padding: 0;
        font-size: inherit;
        margin: 0;
        line-height: inherit;
        padding: 0 6px;
        min-width: 17em;
        vertical-align: top;
        min-height: 1.8em;
        box-sizing: content-box;
    }
    .searchbtn {
        border: 1px solid #cbcbcb;
        line-height: inherit;
        display: inline-block;
        padding: 0 6px;
        background: #fff;
        border-right: 0 none;
        border-left: 1px solid #dcdcdc;
        cursor: pointer;
        margin: 0;
        position: relative;
        color: #666;
    }
    .searchbtn:last-child {
        border-radius: 0 3px 3px 0;
        border-right: 1px solid #cbcbcb;
    }
    .searchbtn:disabled {
        background: none;
        cursor: default;
    }
    .searchbtn:hover {
        background-color: #eef1f6;
    }
    .searchbtn.prev, .searchbtn.next {
         padding: 0px 0.7em
    }
    .searchbtn.prev:after, .searchbtn.next:after {
         content: "";
         border: solid 2px #888;
         width: 0.5em;
         height: 0.5em;
         border-width:  2px 0 0 2px;
         display:inline-block;
         transform: rotate(-45deg);
    }
    .searchbtn.next:after {
         border-width: 0 2px 2px 0 ;
    }
    .folder-bar {
      position: fixed;
      top: 0;
      width: 100%;
      background-color: #f1f1f1;
      border-bottom: 2px solid #eee;
      display: flex;
      padding: 0 10px;
      z-index: 1000;
    }
    .folder-tab {
      background-color: #e0e0e0;
      padding: 10px 20px;
      margin: 10px 5px 0 0;
      border: 1px solid #ccc;
      border-bottom: none;
      border-top-left-radius: 5px;
      border-top-right-radius: 5px;
      cursor: pointer;
      transition: background-color 0.3s;
    }
    .folder-tab:hover {
      background-color: #d5d5d5;
    }
    .folder-tab.active {
      background-color: white;
      font-weight: bold;
      border-bottom: 2px solid white;
    }
    .content {
      padding: 80px 20px 20px;
    }
    .folder-content, .nested-content {
      display: none;
    }
    .folder-content.active, .nested-content.active {
      display: block;
    }
.nested-bar {
  margin-top: 10px;
  border-bottom: 1px solid #ccc;
  display: flex;
  gap: 5px;
  flex-wrap: wrap;
  position: sticky;
  top: 80px; /* keeps it visible under top bar */
  background: #fff;
  z-index: 10;
  padding: 5px 0;
}

.nested-tab {
  background-color: #ddd;
  padding: 6px 15px;
  border: 1px solid #bbb;
  border-radius: 3px 3px 0 0;
  cursor: pointer;
  transition: background-color 0.2s;
}

.nested-tab:hover {
  background-color: #ccc;
}

.nested-tab.active {
  background-color: #fff;
  font-weight: bold;
  border-bottom: 2px solid #5771a9;
}

.nested-content {
  border: 1px solid #ccc;
  border-top: none;
  padding: 10px;
  margin-bottom: 10px;
  border-radius: 0 0 4px 4px;
  background: #fafafa;
  display: block; /* Always visible (stacked) */
}

.nested-content.highlighted {
  border: 2px solid #5771a9;
  background: #ffffff;
  scroll-margin-top: 120px;
}
    .counter {
      margin-top: 15px;
      display: flex;
      align-folders: center;
      gap: 10px;
      flex-wrap: wrap;
    }
    .counter input[type="number"] {
      width: 80px;
      padding: 5px;
      font-size: 16px;
      text-align: center;
    }
    .counter button {
      padding: 5px 10px;
      font-size: 16px;
      cursor: pointer;
    }
    .add-folder {
      margin-top: 10px;
      display: inline-block;
      padding: 5px 10px;
      background-color: #4caf50;
      color: white;
      border: none;
      border-radius: 3px;
      cursor: pointer;
    }
    .add-folder:hover {
      background-color: #45a049;
    }
    .delete-folder {
      margin-top: 10px;
      background-color: #e53935;
      color: white;
      border: none;
      padding: 5px 10px;
      border-radius: 3px;
      cursor: pointer;
    }
    .delete-folder:hover {
      background-color: #d32f2f;
    }
    .readonly-list {
     padding: 10px;
     font-family: monospace;
     white-space: pre;
    } 
    #allfoldersList {
      width: 100%;
      border-collapse: collapse;
      margin-top: 10px;
    }
    #allfoldersList td {
     padding: 6px 10px;
     border-bottom: 1px solid #ccc;
    }
    .nav-brand {
      margin-top: 65px;
      left: 5px;
    }
  </style>
</head>
<body>
  <div class="nav-brand"> <a href="/"><img src="https://homepage.internal.leahycenter.org/img/leahyCenter.png" alt="lcdi logo" id="logo" style="height: 48px;"></a> </div>
  <div class="search">
     <div class="search_form">
      <input class="search_field" placeholder="Search for" spellcheck="false">
       <span action="findPrev" class="searchbtn prev"> </span>
      <span action="findNext" class="searchbtn next"> </span>
      <span class="search_counter">1 of 0</span>
     </div>
  </div>
  <div class="folder-bar">
    <div class="folder-tab active" data-folder="OfficeSupplies">Office Supplies</div>
    <div class="folder-tab" data-folder="TechEquipment">Tech Equipment</div>
    <div class="folder-tab" data-folder="Laptops">Laptops</div>
    <div class="folder-tab" data-folder="folderAll">All</div>
  </div>
  <div class="content">
    <div id="OfficeSupplies" class="folder-content active" data-folder-id="OfficeSupplies">
      <div class="nested-bar"></div>
      <button class="add-folder">+ Add Item</button>
    </div>
    <div id="TechEquipment" class="folder-content" data-folder-id="TechEquipment">
      <div class="nested-bar"></div>
      <button class="add-folder">+ Add Item</button>
    </div>
    <div id="Laptops" class="folder-content" data-folder-id="Laptops">
      <div class="nested-bar"></div>
      <button class="add-folder">+ Add Item</button>
    </div>
    <div id="folderAll" class="folder-content" data-folder-id="folderAll">
  <h2>All folders (Read-Only)</h2>

  <div style="margin-bottom:10px;">
    <label for="importAllInput" class="add-folder" style="background:#ff9800; cursor:pointer;">
       Import 
      <input type="file" id="importAllInput" accept=".json" style="display:none;">
    </label>
      <button id="exportAllBtn" class="add-folder" style="background:#2196f3;"> Export </button>

  </div>

  <div class="readonly-list" id="allfoldersList"></div>
</div>
    </div>
  </div>

  <script>
  const lastActiveNestedTab = {};
  let folderCount = 0;

  const topTabs = document.querySelectorAll('.folder-tab');
  const topContents = document.querySelectorAll('.folder-content');

  topTabs.forEach(tab => {
    tab.addEventListener('click', () => {
      const targetId = tab.getAttribute('data-folder');
      topTabs.forEach(t => t.classList.remove('active'));
      topContents.forEach(c => c.classList.remove('active'));
      tab.classList.add('active');
      const folderContent = document.getElementById(targetId);
      folderContent.classList.add('active');

      if (targetId === 'folderAll') {
        updateAllView();
      } else {
        const nestedTabs = folderContent.querySelectorAll('.nested-tab');
        const nestedContents = folderContent.querySelectorAll('.nested-content');
        const activeNestedId = lastActiveNestedTab[targetId] || (nestedTabs[0] && nestedTabs[0].dataset.nested);
        nestedTabs.forEach(t => t.classList.remove('active'));
        nestedContents.forEach(c => c.classList.remove('active'));
        if (activeNestedId) {
          folderContent.querySelector(`.nested-tab[data-nested="${activeNestedId}"]`)?.classList.add('active');
          folderContent.querySelector(`#${activeNestedId}`)?.classList.add('active');
        }
      }
    });
  });

  function setupNestedTabLogic(folderEl) {
  const tabs = folderEl.querySelectorAll('.nested-tab');
  const contents = folderEl.querySelectorAll('.nested-content');
  
  tabs.forEach(tab => {
    tab.addEventListener('click', () => {
      const id = tab.dataset.nested;
      tabs.forEach(t => t.classList.remove('active'));
      tab.classList.add('active');

      contents.forEach(c => c.classList.remove('highlighted'));
      const selected = folderEl.querySelector(`#${id}`);
      selected.classList.add('highlighted');
      selected.scrollIntoView({ behavior: 'smooth', block: 'center' });

      const folderId = folderEl.getAttribute('data-folder-id');
      lastActiveNestedTab[folderId] = id;
    });
  });
}

  function setupCounterLogic(container) {
    const buttons = container.querySelectorAll('button[data-change]');
    const input = container.querySelector('input[type="number"]');
    buttons.forEach(btn => {
      btn.addEventListener('click', () => {
        const change = parseInt(btn.dataset.change, 10);
        let current = parseInt(input.value || '0', 10);
        const min = parseInt(input.min || '0', 10);
        current = Math.max(current + change, min);
        input.value = current;
        updateAllView();
      });
    });
  }

  function setupDeleteButtons(folderEl) {
    const folderId = folderEl.getAttribute('data-folder-id');
    folderEl.querySelectorAll('.delete-folder').forEach(button => {
      button.addEventListener('click', () => {
        const tabId = button.dataset.tab;
        const tab = folderEl.querySelector(`.nested-tab[data-nested="${tabId}"]`);
        const content = folderEl.querySelector(`#${tabId}`);
        const isActive = tab.classList.contains('active');
        if (confirm("Delete folder?")) {
          tab?.remove();
          content?.remove();
        }

        if (isActive) {
          const tabs = folderEl.querySelectorAll('.nested-tab');
          const contents = folderEl.querySelectorAll('.nested-content');
          if (tabs.length > 0) {
            tabs[0].classList.add('active');
            contents[0].classList.add('active');
            lastActiveNestedTab[folderId] = tabs[0].dataset.nested;
          } else {
            lastActiveNestedTab[folderId] = null;
          }
        }
        setupNestedTabLogic(folderEl);
        setupDeleteButtons(folderEl);
        updateAllView();
      });
    });
  }

  document.querySelectorAll('.add-folder').forEach(button => {
  button.addEventListener('click', () => {
    const folderContent = button.closest('.folder-content');
    const folderId = folderContent.getAttribute('data-folder-id');
    const nestedBar = folderContent.querySelector('.nested-bar');
    const name = prompt('Enter folder name:');
    if (!name) return;
    if (name.length > 32) {
      alert("Folder name must be under 32 characters.");
      return;
    }

    const tabId = `${folderId}-sf${++folderCount}`;

    // Create the tab and content elements
    const tab = document.createElement('div');
    tab.className = 'nested-tab';
    tab.dataset.nested = tabId;
    tab.textContent = name;

    const content = document.createElement('div');
    content.className = 'nested-content';
    content.id = tabId;
    content.innerHTML = `
      <h2>${folderId}/${name}</h2>
      <div class="counter">
        <label>Counter:</label>
        <button data-change="-10">-10</button>
        <button data-change="-1">-1</button>
        <input type="number" value="0" min="0">
        <button data-change="1">+1</button>
        <button data-change="10">+10</button>
      </div>
      <button class="delete-folder" data-tab="${tabId}">Delete folder</button>
    `;

    //alphabetical order
    const existingTabs = Array.from(nestedBar.querySelectorAll('.nested-tab'));
    let inserted = false;
    for (const existing of existingTabs) {
      if (existing.textContent.toLowerCase() > name.toLowerCase()) {
        nestedBar.insertBefore(tab, existing);

        const existingContent = folderContent.querySelector(`#${existing.dataset.nested}`);
        folderContent.insertBefore(content, existingContent);
        inserted = true;
        break;
      }
    }

    // If name at the end
    if (!inserted) {
      nestedBar.appendChild(tab);
      folderContent.appendChild(content);
    }

    // Activate visually
    folderContent.querySelectorAll('.nested-tab').forEach(t => t.classList.remove('active'));
    folderContent.querySelectorAll('.nested-content').forEach(c => c.classList.remove('highlighted'));
    tab.classList.add('active');
    content.classList.add('highlighted');

    setupCounterLogic(content);
    setupNestedTabLogic(folderContent);
    setupDeleteButtons(folderContent);
    updateAllView();

    const folderEl = folderContent.getAttribute('data-folder-id');
    lastActiveNestedTab[folderEl] = tabId;
    content.scrollIntoView({ behavior: 'smooth', block: 'center' });
  });
});

  function updateAllView() {
    const list = document.getElementById('allfoldersList');
    list.innerHTML = '';

    document.querySelectorAll('.folder-content').forEach(folder => {
      const folderId = folder.getAttribute('data-folder-id');
      if (folderId === 'folderAll') return;

      const folders = folder.querySelectorAll('.nested-content');
      folders.forEach(sub => {
        const title = sub.querySelector('h2')?.textContent || 'Unnamed';
        const input = sub.querySelector('input[type="number"]');
        const value = input ? input.value.trim() : '0';

        const row = document.createElement('tr');
        const nameCell = document.createElement('td');
        nameCell.textContent = title.trim();
        const valueCell = document.createElement('td');
        valueCell.textContent = value;
        valueCell.style.textAlign = 'right';
        row.appendChild(nameCell);
        row.appendChild(valueCell);
        list.appendChild(row);
      });
    });
  }
  
  // Search
  let searchResults = [];
  let currentIndex = -1;

  const searchInput = document.querySelector('.search_field');
  const prevBtn = document.querySelector('.searchbtn.prev');
  const nextBtn = document.querySelector('.searchbtn.next');
  const counter = document.querySelector('.search_counter');

  function clearHighlights() {
    document.querySelectorAll('.highlight').forEach(el => {
      el.outerHTML = el.innerText;
    });
  }

  function highlightText(text) {
    clearHighlights();
    if (!text.trim()) {
      searchResults = [];
      counter.textContent = '';
      return;
    }
    const walker = document.createTreeWalker(document.body, NodeFilter.SHOW_TEXT, null, false);
    searchResults = [];
    while (walker.nextNode()) {
      const node = walker.currentNode;
      const val = node.nodeValue;
      const idx = val.toLowerCase().indexOf(text.toLowerCase());
      if (idx !== -1 && node.parentElement.closest('.folder-content')) {
        const span = document.createElement('span');
        span.innerHTML =
          val.substring(0, idx) +
          `<mark class="highlight" style="background:yellow">${val.substring(idx, idx + text.length)}</mark>` +
          val.substring(idx + text.length);
        node.parentNode.replaceChild(span, node);
      }
    }
    searchResults = Array.from(document.querySelectorAll('.highlight'));
    if (searchResults.length) {
      currentIndex = 0;
      scrollToResult();
    }
    counter.textContent = searchResults.length
      ? `${currentIndex + 1} of ${searchResults.length}`
      : '0 of 0';
  }

  function scrollToResult() {
    searchResults.forEach((el, i) => {
      el.style.background = i === currentIndex ? 'orange' : 'yellow';
    });
    searchResults[currentIndex]?.scrollIntoView({ behavior: 'smooth', block: 'center' });
    counter.textContent = `${currentIndex + 1} of ${searchResults.length}`;
  }

  nextBtn.addEventListener('click', () => {
    if (searchResults.length === 0) return;
    currentIndex = (currentIndex + 1) % searchResults.length;
    scrollToResult();
  });

  prevBtn.addEventListener('click', () => {
    if (searchResults.length === 0) return;
    currentIndex = (currentIndex - 1 + searchResults.length) % searchResults.length;
    scrollToResult();
  });

  searchInput.addEventListener('input', (e) => {
    highlightText(e.target.value);
  });
  // Search end
 // import and export functions 

  function getAllFolderData() {
    const data = {};
  
    document.querySelectorAll('.folder-content').forEach(folder => {
      const folderId = folder.getAttribute('data-folder-id');
      if (folderId === 'folderAll') return;
      const subfolders = [];
  
      folder.querySelectorAll('.nested-content').forEach(sub => {
        const title = sub.querySelector('h2')?.textContent || 'Unnamed';
        const input = sub.querySelector('input[type="number"]');
        subfolders.push({
          name: title.split('/').slice(1).join('/'),
          count: input ? parseInt(input.value, 10) : 0
        });
      });
  
      data[folderId] = subfolders;
    });
  
    return data;
  }
  function exportAllData(filename = 'inventory_export.json') {
  const data = getAllFolderData();
  if (!data) {
    console.error('No data found to export');
    return;
  }

  const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
  const url = URL.createObjectURL(blob);

  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);

  URL.revokeObjectURL(url);
}
  
  function importAllData(file) {
    const reader = new FileReader();
    reader.onload = e => {
      try {
        const data = JSON.parse(e.target.result);
        restoreFolderData(data);
        alert('Import successful');
      } catch (err) {
        alert('Invalid file format');
      }
    };
    reader.readAsText(file);
  }
  
  function restoreFolderData(data) {
  Object.entries(data).forEach(([folderId, subfolders]) => {
    const folder = document.querySelector(`.folder-content[data-folder-id="${folderId}"]`);
    if (!folder) return;
    const nestedBar = folder.querySelector('.nested-bar');

    // Read existing subfolders into a Map for quick lookup
    const existingTabs = Array.from(nestedBar.querySelectorAll('.nested-tab'));
    const existingMap = new Map(
      existingTabs.map(tab => [tab.textContent.toLowerCase(), tab.dataset.nested])
    );

    subfolders.forEach(sub => {
      const subName = sub.name.trim();
      const lower = subName.toLowerCase();

      // If it already exists, just update the counter
      if (existingMap.has(lower)) {
        const existingId = existingMap.get(lower);
        const existingContent = folder.querySelector(`#${existingId}`);
        const input = existingContent.querySelector('input[type="number"]');
        input.value = sub.count;
        return;
      }

      // Otherwise, create a brand new subfolder
      const tabId = `${folderId}-sf${++folderCount}`;
      const tab = document.createElement('div');
      tab.className = 'nested-tab';
      tab.dataset.nested = tabId;
      tab.textContent = subName;

      const content = document.createElement('div');
      content.className = 'nested-content';
      content.id = tabId;
      content.innerHTML = `
        <h2>${folderId}/${subName}</h2>
        <div class="counter">
          <label>Counter:</label>
          <button data-change="-10">-10</button>
          <button data-change="-1">-1</button>
          <input type="number" value="${sub.count}" min="0">
          <button data-change="1">+1</button>
          <button data-change="10">+10</button>
        </div>
        <button class="delete-folder" data-tab="${tabId}">Delete folder</button>
      `;

      // Insert alphabetically
      const existing = Array.from(nestedBar.querySelectorAll('.nested-tab'));
      let inserted = false;
      for (const existingTab of existing) {
        if (existingTab.textContent.toLowerCase() > subName.toLowerCase()) {
          nestedBar.insertBefore(tab, existingTab);
          const existingContent = folder.querySelector(`#${existingTab.dataset.nested}`);
          folder.insertBefore(content, existingContent);
          inserted = true;
          break;
        }
      }
      if (!inserted) {
        nestedBar.appendChild(tab);
        folder.appendChild(content);
      }

      setupCounterLogic(content);
    });

    setupNestedTabLogic(folder);
    setupDeleteButtons(folder);
  });

  updateAllView();
  }
  
  // Hook up event listeners
  document.getElementById('exportAllBtn').addEventListener('click', exportAllData);
  document.getElementById('importAllInput').addEventListener('change', e => {
    const file = e.target.files[0];
    if (file) importAllData(file);
  });
  // import/export end
  updateAllView();

</script>

</body>
</html>
